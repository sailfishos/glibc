From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Bj=C3=B6rn=20Bidar?= <bjorn.bidar@jolla.com>
Date: Tue, 31 Aug 2021 02:16:50 +0300
Subject: [PATCH] Define bits/endian.h instead of generating it

---
 bits/endian.h   | 15 +++++------
 bits/errno.h    | 68 ++++++++++++++++++++++++++++++++++---------------
 bits/wordsize.h | 10 +++-----
 3 files changed, 57 insertions(+), 36 deletions(-)

diff --git a/bits/endian.h b/bits/endian.h
index 45afd4ae..f49f6ab1 100644
--- a/bits/endian.h
+++ b/bits/endian.h
@@ -1,13 +1,10 @@
-/* This file should define __BYTE_ORDER as appropriate for the machine
-   in question.  See string/endian.h for how to define it.
-
-   If only the stub bits/endian.h applies to a particular configuration,
-   bytesex.h is generated by running a program on the host machine.
-   So if cross-compiling to a machine with a different byte order,
-   the bits/endian.h file for that machine must exist.  */
-
 #ifndef _ENDIAN_H
 # error "Never use <bits/endian.h> directly; include <endian.h> instead."
 #endif
 
-#error Machine byte order unknown.
+/* ARM can be either big or little endian.  */
+#ifdef __ARMEB__
+#define __BYTE_ORDER __BIG_ENDIAN
+#else
+#define __BYTE_ORDER __LITTLE_ENDIAN
+#endif
diff --git a/bits/errno.h b/bits/errno.h
index 4a2c2f46..fd9e331f 100644
--- a/bits/errno.h
+++ b/bits/errno.h
@@ -25,26 +25,52 @@
 # error "Never include <bits/errno.h> directly; use <errno.h> instead."
 #endif
 
-#error "Generic bits/errno.h included -- port is incomplete."
-
-/* Authors of new ports of the GNU C Library must override this file
-   with their own bits/errno.h in an appropriate subdirectory of
-   sysdeps/.  Its function is to define all of the error constants
-   from C2011 and POSIX.1-2008, with values appropriate to the
-   operating system, and any additional OS-specific error constants.
-
-   C2011 requires all error constants to be object-like macros that
-   expand to "integer constant expressions with type int, positive
-   values, and suitable for use in #if directives".  Moreover, all of
-   their names must begin with a capital E, followed immediately by
-   either another capital letter, or a digit.  It is OK to define
-   macros that are not error constants, but only in the implementation
-   namespace.
-
-   errno.h is sometimes included from assembly language.  Therefore,
-   when __ASSEMBLER__ is defined, bits/errno.h may only define macros;
-   it may not make any other kind of C declaration or definition.
-   Also, the error constants should, if at all possible, expand to
-   simple decimal or hexadecimal numbers.  */
+#ifdef _ERRNO_H
+
+# include <linux/errno.h>
+
+/* Older Linux headers do not define these constants.  */
+# ifndef ENOTSUP
+#   define ENOTSUP EOPNOTSUPP
+# endif
+
+/* Older Linux versions also had no ECANCELED error code.  */
+# ifndef ECANCELED
+#  define ECANCELED	125
+# endif
+
+/* Support for error codes to support robust mutexes was added later, too.  */
+# ifndef EOWNERDEAD
+#  define EOWNERDEAD		130
+#  define ENOTRECOVERABLE	131
+# endif
+
+# ifndef ERFKILL
+#  define ERFKILL		132
+# endif
+
+# ifndef EHWPOISON
+#  define EHWPOISON		133
+# endif
+
+# ifndef __ASSEMBLER__
+/* Function to get address of global `errno' variable.  */
+extern int *__errno_location (void) __THROW __attribute__ ((__const__));
+
+#  if !defined _LIBC || defined _LIBC_REENTRANT
+/* When using threads, errno is a per-thread value.  */
+#   define errno (*__errno_location ())
+#  endif
+# endif /* !__ASSEMBLER__ */
+#endif /* _ERRNO_H */
+
+#if !defined _ERRNO_H && defined __need_Emath
+/* This is ugly but the kernel header is not clean enough.  We must
+   define only the values EDOM, EILSEQ and ERANGE in case __need_Emath is
+   defined.  */
+# define EDOM	33	/* Math argument out of domain of function.  */
+# define EILSEQ	84	/* Illegal byte sequence.  */
+# define ERANGE	34	/* Math result not representable.  */
+#endif /* !_ERRNO_H && __need_Emath */
 
 #endif /* bits/errno.h.  */
diff --git a/bits/wordsize.h b/bits/wordsize.h
index 53013a92..fa31ec60 100644
--- a/bits/wordsize.h
+++ b/bits/wordsize.h
@@ -1,24 +1,22 @@
-#error "This file must be written based on the data type sizes of the target"
-
 /* The following entries are a template for what defines should be in the
    wordsize.h header file for a target.  */
 
 /* Size in bits of the 'long int' and pointer types.  */
-#define __WORDSIZE
+#define __WORDSIZE 32
 
 /* This should be set to 1 if __WORDSIZE is 32 and size_t is type
    'unsigned long' instead of type 'unsigned int'.  This will ensure
    that SIZE_MAX is defined as an unsigned long constant instead of an
    unsigned int constant.  Set to 0 if __WORDSIZE is 32 and size_t is
    'unsigned int' and leave undefined if __WORDSIZE is 64.  */
-#define __WORDSIZE32_SIZE_ULONG
+#define __WORDSIZE32_SIZE_ULONG 0
 
 /* This should be set to 1 if __WORDSIZE is 32 and ptrdiff_t is type 'long'
    instead of type 'int'.  This will ensure that PTRDIFF_MIN and PTRDIFF_MAX
    are defined as long constants instead of int constants.  Set to 0 if
    __WORDSIZE is 32 and ptrdiff_t is type 'int' and leave undefined if
    __WORDSIZE is 64.  */
-#define __WORDSIZE32_PTRDIFF_LONG
+#define __WORDSIZE32_PTRDIFF_LONG 0
 
 /* Set to 1 in order to force time types to be 32 bits instead of 64 bits in
    struct lastlog and struct utmp{,x}.  This may be done in
@@ -26,4 +24,4 @@
    64-bit ports where the time types are 64-bits and new 32-bit ports
    where time_t is 64 bits, and there is no companion architecture with
    32-bit time_t.  */
-#define __WORDSIZE_TIME64_COMPAT32
+#define __WORDSIZE_TIME64_COMPAT32 0
